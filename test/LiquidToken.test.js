const LiquidToken = artifacts.require("liquidtoken.sol");

var chai = require("chai");
const BN = web3.utils.BN;
const chaiBN = require("chai-bn")(BN);
chai.use(chaiBN);

var chaiAsPromised = require("chai-as-promised");
chai.use(chaiAsPromised);

const expect = chai.expect;

contract("LiquidToken", async (accounts) => {
  const [creator, recipient, anotherAccount] = await accounts;

  it("mint initial supply in creator's account", async () => {
    let instance = await LiquidToken.deployed();
    let totalSupply = await instance.totalSupply();
    //let balance = await instance.balanceOf (creatorAddress);
    // assert.equal (balance.valueOf(), totalSupply.valueOf(), "Balance was not the same")

    //using chai
    // expect(await instance.balanceOf(creatorAddress)).to.be.a.bignumber.equal(
    //   totalSupply);

    //Using chai-as-promised: no await reqd.
    expect(instance.balanceOf(creator)).to.eventually.be.a.bignumber.equal(
      totalSupply
    );
  });

  it("is possible to send tokens between accounts", async () => {
    let instance = await LiquidToken.deployed();
    const sendAmount = 1;
    let totalSupply = await instance.totalSupply();
    expect(instance.balanceOf(creator)).to.eventually.be.a.bignumber.equal(
      totalSupply
    );
    expect(instance.transfer(recipient, new BN(sendAmount))).to.eventually.be
      .fulfilled;
    expect(instance.balanceOf(creator)).to.eventually.be.a.bignumber.equal(
      totalSupply.sub(new BN(sendAmount))
    );
    expect(instance.balanceOf(recipient)).to.eventually.be.a.bignumber.equal(
      new BN(sendAmount)
    );
  });

  it("is not possible to send an amount greater than the total supply", async () => {
    let instance = await LiquidToken.deployed();
    const creatorBalance = await instance.balanceOf(creator);
    const sendAmount = creatorBalance + 1;

    return expect(
      instance.transfer(recipient, new BN(sendAmount))
    ).to.eventually.be.rejectedWith(TypeError);
    // expect(instance.balanceOf(creator)).to.eventually.be.a.bignumber.equal(
    //   creatorBalance
    // );
  });
});

/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test <path/to/this/test.js>
 *
 * */
//  var LiquidToken = artifacts.require("e:\Web3.js\asset\contracts\liquidtoken.sol");

//  contract('LiquidToken', (accounts) => {
//      var creatorAddress = accounts[0];
//      var firstOwnerAddress = accounts[1];
//      var secondOwnerAddress = accounts[2];
//      var externalAddress = accounts[3];
//      var unprivilegedAddress = accounts[4]
//      /* create named accounts for contract roles */

//      before(async () => {
//          /* before tests */
//      })

//      beforeEach(async () => {
//          /* before each context */
//      })

//      it('should revert if ...', () => {
//          return LiquidToken.deployed()
//              .then(instance => {
//                  return instance.publicOrExternalContractMethod(argument1, argument2, {from:externalAddress});
//              })
//              .then(result => {
//                  assert.fail();
//              })
//              .catch(error => {
//                  assert.notEqual(error.message, "assert.fail()", "Reason ...");
//              });
//          });

//      context('testgroup - security tests - description...', () => {
//          //deploy a new contract
//          before(async () => {
//              /* before tests */
//              const newLiquidToken =  await LiquidToken.new()
//          })

//          beforeEach(async () => {
//              /* before each tests */
//          })

//          it('fails on initialize ...', async () => {
//              return assertRevert(async () => {
//                  await newLiquidToken.initialize()
//              })
//          })

//          it('checks if method returns true', async () => {
//              assert.isTrue(await newLiquidToken.thisMethodShouldReturnTrue())
//          })
//      })
//  });
